## OOP
---
## 절차지향
  - 함수로 나뉘고
  - 이름이 부여되어
  - 잘게 쪼개진 코드 조각
  - 함수는 프로그래머의 이해와
  - 유지 보수를 쉽게하기 위한
  - 추상화 도구
---
## 절차지향
  - 규모가 크면
  - 선형적인 이벤트 순서만으로 이루어지기 어렵다
---
## 절차지향
  - 이 프로그램은 어떤 일을 하는가?
---
## 객체 지향
  - 실세계의 객체를 어떻게 모델링할 것인가?
---
## class
  - 계층, 분류, 유형
  - 모든 객체는 특정 클래스에 속해 있다
  - 객체는 어떤 클래스의 실재하는 물건
  - 실사례 : 인스턴스 --> 어떤 클래스에 속하지만
    같은 클래스에 속한 다른 객체와 구별되는 특징을 
    가진다
---
## 메서드
  - 절차를 이루던 함수들이 객체로 옮겨진다
  - 코드를 데이터와 연계
---
## 객체지향
  - 객체 : 데이터와 함수를 묶어주는 좋은 툴
    --> 가독성과 유지 보수성을 높인다
---
## 객체지향
  - 과도하게 일반적인 객체
    - 객체가 상당히 추상적인 경우가 많다
  - 애플리케이션 객체
    - 애플리케이션 자체는 물리적으로 표현할 수 없지만
    - 어떤 멤버와 메서드를 가지고 있어
    - 객체화하는 것이 유용하다
---
## 객체지향
  - 일반적인 객체
    -> 어떤 특정한 것을 표현하지 않는다
  - 혼란스러움
  - 멤버와 메서드를 보면 과도하게 일반적인지 아닌지 알 수 있다
  - 데이터 : 너무 일반적
  - 실행 : method 일반적
  - 미디어 : 대응되는 구체적인 객체가 없다
  - 사용자 인터페이스에도 없고 실세계에도 없고 프로그래머 머리속에도 없다
---
## 객체지향
  - 프로그래머의 여러 아이디어가 한 개의 클래스에 모두 합쳐졌다면 과도하게 일반적인 가능성이 높다
---
## 객체 간 관계
  - 서로 다른 클래스가 공통적인 속성, 연관 관계가 있는 경우
---
## HAS-A
  - 동물원과 원숭이
  - 창과 버튼
---
## IS-A
  - 무엇은 무엇의 한 종류다
  - 파생, 서브클래싱, 확장, 상속
  - 객체지향 프로그램의 근간
  - 클래스 모델 : 실세계의 것들이  프로퍼티와 행동으로 이루어져 있다는 데 기반
  - 상속 모델 : 이런 객체들이 어떤 계층을 이루며 조직화되는 경향이 있다는 사실에 기반
---
## IS-A
  - 관계를 형성 : 어떤 공통점을 갖는다
  - 원숭이, 기린, 캥거루, 펭권
  - Animal 클래스를 통해 모든 동물이 가지는 프로퍼티(크기, 위치, 사료)와 행동(이동, 먹기, 잠자기)을 하나로 감쌀 수 있다
  - 원숭이는 동물의 특성에 원숭이만의 특성이 더해진다
---
## IS-A
  - 공통의 기능을 상위 클래스에 묶어 다른 클래스로 확장할 수 있게 하는 것이 목적
---
## 클래스 상속 요령
  - 'A는 ~하고 ~하는 B다'
  - 기능 추가
    -  Monkey 클래스 : Animal의 모든 행동을 가지면서
    -  추가로 원숭이만의  요소인 '나무 건너뛰기' 행동을 가진다
---
## 기능 변경
  - 부모 클래스의 행동을 완전히 바꾸는 오버라이딩을 통해 파생 클래스를 만들 수 있다
  - 다른 행동은 모두 동일하게 적용받지만 이동에 대해서는 다른 방식이 적용되는 Kangaroo 클래스
  - 베이스 클래스의 모든 행동을 바꾼다면 추상 클래스를 제외하고 파생 클래스를 만드는 것이 잘못된 디자인임을 암시한다
  - 추상 클래스는 인스턴스 만들지 못하고 파생 클래스들이 각기 특정 행동을 구현
---
## 프로퍼티 추가
  - 베이스 클래스에 새로운 프로퍼티 추가되어 파생 클래스를 만든다
---
## 다형성
  - 표준적인 프로퍼티와 행동의 집합을 정의하고
  - 그것을 따르는 객체라면 그 중 어느 객체를 이용해도
  - 정상적으로 이용할 수 있다
  - Monkey 객체는 Animal 클래스의 프로퍼티와 행동을 지원
---
## 코드 재활용
  - IS-A가 아니더라도 코드를 재활용하기 위해 상속을 하기도 한다
---
## 클래스 계층
  - 파생 클래스를 구현하면서 유사한 부분을 많이 발견하게 되면 해당 부분을 공통의 부모 클래스에 집어넣는 것이 좋다
  - Lion  클래스와 Panther 클래스를 구현하다보면 이동 방식과  먹이가 비슷함을 알 수 있다. 이때 BigCat이라는 부모 클래스를 만드는 것이 바람직함을 암시한다
---
## 클래스 계층
  - 클래스가 어떤 방식으로 이용될 것인가가 중요하다
  - 필요에 맞추어 객체의 계층이 디자인된다
  - 좋은 계층 디자인
    - 클래스의 의미있는 기능적 관계에 따라 조직화한다
    - 공통 부분을 베이스 클래스에 위치시킴으로써 코드를 재사용할 수 있게 한다
    - 부모가 추상 클래스일 경우를 제외하고 베이스 클래스의 많은 부분을 오버라이딩하는 파생 클래스의 도입은 피함
---
## 유틸리티 클래스
  - 애플리케이션 안에서 일반적으로 사용될 어떤 기능을 만들어야 할 때가 있다
  - 랜덤 넘버 생성 라이브러리나 로그 저장 클래스
  - 거의 모든 기능을 외부에서 사용하기 때문에 내부 구현을 너무 드러내지 않는 선에서 모두 노출하면 된다
---
## 추상화
  - 해당 클래스의 이용 방법 : 인터페이스
  - 추상화 : 인터페이스를 구현과 분리
  - 구현 : 목적하는 작업을 수행하도록 작성한 코드
  - 인터페이스 : 다른 사람이 그 코드를 이용할 때 사용해야 하는 규약
  - 클래스의 접근 가능한 프로퍼티와 행동이 인터페이스 역할을 한다
---
## 추상화
  - 좋은 인터페이스 
    - 공개된 행동만으로 이루어진다
    - 프로퍼티와 값은 그 자체로는 공개되지 않고
    - 게터와 세터에 의해 공개된다
---
## 추상화 디자인
  - 코드가 많아지고 구조가 깊어진다면 클래스를 쪼갠다
  - 가능하면 프로퍼티를 행동으로 바꾼다
    - property 적극 이용??
  - 물건의 크기를 나타내는 프로퍼티에 마이너스 값을 집어넣는 오류를 피하고 싶다면 프로퍼티 변수를 직접 노출하는 대신 setHeight()라는 행동을 정의해서 값을 설정하기 전에 올바른지 검사할 수 있다. 
